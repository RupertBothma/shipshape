#!/usr/bin/env bash
# backup-configmaps.sh â€” Backup and restore helloworld ConfigMaps.
#
# Usage:
#   ./scripts/backup-configmaps.sh backup [output-dir]
#   ./scripts/backup-configmaps.sh restore <backup-dir>
#
# Defaults:
#   NAMESPACE=shipshape
#   LABEL_SELECTOR=app=helloworld
#   Output directory: ./configmap-backups/<timestamp>
#   Backup format: metadata-sanitized JSON manifests

set -euo pipefail

NAMESPACE="${NAMESPACE:-shipshape}"
LABEL_SELECTOR="${LABEL_SELECTOR:-app=helloworld}"

sanitize_manifest() {
    local input_file="$1"
    local output_file="$2"
    local namespace="$3"

    python3 - "$input_file" "$output_file" "$namespace" <<'PY'
from __future__ import annotations

import json
import sys
from pathlib import Path

input_path = Path(sys.argv[1])
output_path = Path(sys.argv[2])
namespace = sys.argv[3]

raw = input_path.read_text(encoding="utf-8")
doc: dict[str, object]
try:
    parsed = json.loads(raw)
except json.JSONDecodeError:
    try:
        import yaml  # type: ignore[import-not-found]
    except Exception as exc:  # pragma: no cover - depends on local environment
        raise SystemExit(
            f"{input_path}: non-JSON manifest and PyYAML is unavailable ({exc}). "
            "Install PyYAML or use JSON backups generated by this script."
        ) from exc
    parsed = yaml.safe_load(raw)

if not isinstance(parsed, dict):
    raise SystemExit(f"{input_path}: expected a single ConfigMap object")

if parsed.get("kind") != "ConfigMap":
    raise SystemExit(f"{input_path}: expected kind=ConfigMap")

metadata = parsed.get("metadata")
if not isinstance(metadata, dict):
    raise SystemExit(f"{input_path}: missing metadata")

name = metadata.get("name")
if not isinstance(name, str) or not name:
    raise SystemExit(f"{input_path}: missing metadata.name")

clean_metadata: dict[str, object] = {"name": name, "namespace": namespace}

labels = metadata.get("labels")
if isinstance(labels, dict) and labels:
    clean_metadata["labels"] = labels

annotations = metadata.get("annotations")
if isinstance(annotations, dict):
    clean_annotations = {
        key: value
        for key, value in annotations.items()
        if key != "kubectl.kubernetes.io/last-applied-configuration"
    }
    if clean_annotations:
        clean_metadata["annotations"] = clean_annotations

sanitized: dict[str, object] = {
    "apiVersion": "v1",
    "kind": "ConfigMap",
    "metadata": clean_metadata,
}
for field in ("data", "binaryData", "immutable"):
    value = parsed.get(field)
    if value is not None:
        sanitized[field] = value

output_path.write_text(json.dumps(sanitized, indent=2, sort_keys=True) + "\n", encoding="utf-8")
PY
}

manifest_name() {
    local file="$1"
    python3 - "$file" <<'PY'
from __future__ import annotations

import json
import sys
from pathlib import Path

doc = json.loads(Path(sys.argv[1]).read_text(encoding="utf-8"))
metadata = doc.get("metadata", {})
if not isinstance(metadata, dict):
    raise SystemExit("missing metadata")
name = metadata.get("name")
if not isinstance(name, str) or not name:
    raise SystemExit("missing metadata.name")
print(name)
PY
}

backup() {
    local output_dir="${1:-configmap-backups/$(date +%Y%m%dT%H%M%S)}"
    local raw_file
    mkdir -p "$output_dir"

    echo "Backing up ConfigMaps in namespace=$NAMESPACE selector=$LABEL_SELECTOR"

    local configmaps
    configmaps=$(kubectl -n "$NAMESPACE" get configmap -l "$LABEL_SELECTOR" -o name)

    if [ -z "$configmaps" ]; then
        echo "No ConfigMaps found matching selector $LABEL_SELECTOR"
        exit 1
    fi

    for cm in $configmaps; do
        local name
        name=$(basename "$cm")
        local file="$output_dir/${name}.json"
        raw_file="$(mktemp)"
        kubectl -n "$NAMESPACE" get "$cm" -o json > "$raw_file"
        sanitize_manifest "$raw_file" "$file" "$NAMESPACE"
        rm -f "$raw_file"
        echo "  Backed up $name -> $file (sanitized metadata)"
    done

    echo "Backup complete: $output_dir"
}

restore() {
    local backup_dir="$1"
    local sanitized_file
    local restored=0

    if [ ! -d "$backup_dir" ]; then
        echo "Error: directory $backup_dir does not exist"
        exit 1
    fi

    echo "Restoring ConfigMaps from $backup_dir to namespace=$NAMESPACE"

    shopt -s nullglob
    local files=("$backup_dir"/*.json "$backup_dir"/*.yaml "$backup_dir"/*.yml)
    shopt -u nullglob
    if [ "${#files[@]}" -eq 0 ]; then
        echo "Error: no manifest files found in $backup_dir"
        exit 1
    fi

    for file in "${files[@]}"; do
        [ -f "$file" ] || continue
        sanitized_file="$(mktemp)"
        sanitize_manifest "$file" "$sanitized_file" "$NAMESPACE"
        local name
        name="$(manifest_name "$sanitized_file")"
        kubectl apply --dry-run=server -n "$NAMESPACE" -f "$sanitized_file" >/dev/null
        kubectl apply -n "$NAMESPACE" -f "$sanitized_file" >/dev/null
        rm -f "$sanitized_file"
        restored=$((restored + 1))
        echo "  Restored $name (validated with --dry-run=server)"
    done

    echo "Restore complete ($restored ConfigMap object(s)). Controller will detect changes and trigger restarts."
}

case "${1:-}" in
    backup)
        backup "${2:-}"
        ;;
    restore)
        if [ -z "${2:-}" ]; then
            echo "Usage: $0 restore <backup-dir>"
            exit 1
        fi
        restore "$2"
        ;;
    *)
        echo "Usage: $0 {backup|restore} [args]"
        exit 1
        ;;
esac
